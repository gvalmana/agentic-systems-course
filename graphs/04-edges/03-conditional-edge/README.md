# Conditional Edge: Sentiment-Based Router

## üéØ Reto

Construye un sistema de procesamiento de texto que analice el sentimiento del mensaje y proporcione respuestas personalizadas seg√∫n la emoci√≥n detectada.

**Requisitos:**

- Crear un grafo usando LangGraph que implemente un router basado en el sentimiento del texto
- El sistema debe:
  1. Analizar si un texto es positivo, negativo o neutral
  2. Enrutar el texto al procesador adecuado seg√∫n el sentimiento
  3. Generar una respuesta apropiada para cada tipo de sentimiento:
     - Textos positivos ‚Üí Respuesta entusiasta
     - Textos negativos ‚Üí Respuesta emp√°tica
     - Textos neutrales ‚Üí Respuesta objetiva
- Implementar edges condicionales para el enrutamiento din√°mico
- Mantener un estado que registre:
  - El texto original
  - El sentimiento detectado
  - Las respuestas generadas
  - La salida final

**Ejemplo de entrada/salida esperada:**

```typescript
// Entrada positiva
Input: "¬°Me encanta este nuevo proyecto!"
Output: {
  user_input: "¬°Me encanta este nuevo proyecto!",
  sentiment: "positive",
  graph_output: "¬°Qu√© maravilloso ver tu entusiasmo! Tu energ√≠a positiva..."
}

// Entrada negativa
Input: "Me siento muy frustrado con estos errores."
Output: {
  user_input: "Me siento muy frustrado con estos errores.",
  sentiment: "negative",
  graph_output: "Entiendo tu frustraci√≥n. Es normal sentirse as√≠ cuando..."
}
```

## Soluci√≥n

Este ejemplo demuestra c√≥mo usar edges condicionales en LangGraph para crear un router basado en sentimientos que procesa texto de manera diferente seg√∫n su contenido emocional.

## üìä Diagrama del Flujo

```mermaid
graph TD
    A[START] --> B[Analyze Sentiment]
    B -->|Positive| C[Process Positive]
    B -->|Negative| D[Process Negative]
    B -->|Neutral| E[Process Neutral]
    C --> F[END]
    D --> F
    E --> F
```

## üîÑ Estado del Grafo

```typescript
{
    user_input: string,           // Texto original del usuario
    sentiment: string,            // Resultado del an√°lisis de sentimiento
    positive_response: string,    // Respuesta para texto positivo
    negative_response: string,    // Respuesta para texto negativo
    neutral_response: string,     // Respuesta para texto neutral
    graph_output: string         // Respuesta final seleccionada
}
```

## üéØ Nodos del Grafo

### 1. Analyze Sentiment

- **Entrada**: `state.user_input`
- **Proceso**: Analiza el sentimiento del texto
- **Salida**: `sentiment` ('positive', 'negative', o 'neutral')

### 2. Process Positive

- **Entrada**: `state.user_input`
- **Proceso**: Genera una respuesta entusiasta
- **Salida**: `positive_response` y `graph_output`

### 3. Process Negative

- **Entrada**: `state.user_input`
- **Proceso**: Genera una respuesta emp√°tica
- **Salida**: `negative_response` y `graph_output`

### 4. Process Neutral

- **Entrada**: `state.user_input`
- **Proceso**: Genera una respuesta objetiva
- **Salida**: `neutral_response` y `graph_output`

## üîÄ Edge Condicional

La funci√≥n `routeBySentiment` determina la ruta a seguir basada en el sentimiento, y luego el mapeo en `addConditionalEdges` traduce esa ruta al nodo correspondiente:

```typescript
// Funci√≥n que determina la ruta l√≥gica
const routeBySentiment = (state: typeof stateSchema.State) => {
  switch (state.sentiment) {
    case "positive":
      return "ROUTE_TO_POSITIVE";    // Identificador de ruta para contenido positivo
    case "negative":
      return "ROUTE_TO_NEGATIVE";    // Identificador de ruta para contenido negativo
    default:
      return "ROUTE_TO_NEUTRAL";     // Identificador de ruta para contenido neutral
  }
};

// Mapeo de rutas l√≥gicas a nodos reales en addConditionalEdges
{
  ROUTE_TO_POSITIVE: "process_positive",  // Ruta positiva -> Nodo de procesamiento positivo
  ROUTE_TO_NEGATIVE: "process_negative",  // Ruta negativa -> Nodo de procesamiento negativo
  ROUTE_TO_NEUTRAL: "process_neutral"     // Ruta neutral -> Nodo de procesamiento neutral
}
```

### Enfoques para addConditionalEdges

LangGraph permite dos enfoques diferentes para implementar edges condicionales:

#### 1. Usando Mapeo de Rutas (Enfoque con Objeto)

Este es el enfoque usado en este ejemplo, donde:

- La funci√≥n condicional retorna un string que act√∫a como identificador de ruta
- `addConditionalEdges` recibe un objeto que mapea esos identificadores a nodos reales
- Es √∫til cuando quieres separar la l√≥gica de enrutamiento de los nombres de los nodos
- Solo permite enrutar a un nodo a la vez

```typescript
// Funci√≥n retorna un identificador
const routeBySentiment = (state) => {
  return "ROUTE_TO_POSITIVE";  // Retorna una clave
}

// addConditionalEdges usa un objeto para mapear
.addConditionalEdges("node_a", routeBySentiment, {
  ROUTE_TO_POSITIVE: "process_positive",  // Mapeo de clave a nodo
})
```

#### 2. Usando Nombres de Nodos Directos (Enfoque con Array)

Un enfoque alternativo donde:

- La funci√≥n condicional retorna directamente un array con los nombres de los nodos destino
- `addConditionalEdges` recibe un array con todos los posibles nodos destino
- Es m√°s directo cuando conoces los nombres exactos de los nodos
- Permite ejecuci√≥n en paralelo retornando m√∫ltiples nodos

```typescript
// Funci√≥n retorna directamente nombres de nodos
const routeToNodes = (state) => {
  if (condition) {
    return ["node_b", "node_c"];  // Ejecutar√° B y C en paralelo
  }
  return ["node_d"];              // Ejecutar√° solo D
}

// addConditionalEdges usa un array de posibles destinos
.addConditionalEdges("node_a", routeToNodes, ["node_b", "node_c", "node_d"])
```

#### ¬øCu√°ndo usar cada enfoque?

1. **Usa el enfoque con Objeto (Mapeo de Rutas) cuando:**

   - Quieres separar la l√≥gica de enrutamiento de los nombres de nodos
   - Los nombres de las rutas son significativamente diferentes de los nombres de los nodos
   - Solo necesitas enrutar a un nodo a la vez
   - Prefieres una capa extra de indirecci√≥n para mejor mantenibilidad

2. **Usa el enfoque con Array (Nombres Directos) cuando:**
   - Necesitas ejecutar m√∫ltiples nodos en paralelo
   - Los nombres de los nodos son simples y directos
   - No necesitas una capa extra de indirecci√≥n
   - Quieres mantener la l√≥gica m√°s simple y directa

## üìù Ejemplo de Uso

```typescript
// Importar el handler
import { handler } from "./index";

// Ejemplo con texto positivo
await handler("¬°Me encanta este nuevo proyecto!");
// Resultado: Respuesta entusiasta y motivadora

// Ejemplo con texto negativo
await handler("Me siento muy frustrado con estos errores.");
// Resultado: Respuesta emp√°tica y de apoyo

// Ejemplo con texto neutral
await handler("El cielo est√° nublado hoy.");
// Resultado: Respuesta objetiva y balanceada
```

## üîë Conceptos Clave

1. **Edge Condicional**:

   - Uso de `addConditionalEdges` para enrutamiento din√°mico
   - Separaci√≥n clara entre rutas l√≥gicas (`ROUTE_TO_*`) y nodos destino (`process_*`)
   - Mapeo expl√≠cito de rutas a nodos para mejor mantenibilidad

2. **Estado M√∫ltiple**:

   - Manejo de diferentes tipos de respuestas en el estado
   - Cada nodo actualiza su parte espec√≠fica del estado

3. **Procesamiento Espec√≠fico**:

   - Nodos especializados para cada tipo de sentimiento
   - Cada nodo tiene una responsabilidad √∫nica y clara

4. **Flujo Din√°mico**:
   - El camino a trav√©s del grafo se determina en tiempo de ejecuci√≥n
   - Las decisiones de enrutamiento se basan en el an√°lisis del contenido

## üõ†Ô∏è Configuraci√≥n Necesaria

1. Archivo `.env` con:

```
OPENAI_API_KEY=tu-api-key-aqu√≠
```

2. Dependencias:

```json
{
  "@langchain/openai": "latest",
  "@langchain/langgraph": "latest",
  "@langchain/core": "latest"
}
```

Este ejemplo muestra c√≥mo los edges condicionales permiten crear flujos de trabajo din√°micos que se adaptan al contenido del input, permitiendo respuestas m√°s contextuales y apropiadas.
